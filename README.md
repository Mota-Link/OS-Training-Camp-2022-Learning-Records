# OS-Training-Camp-2022-Learning-Records
2022年开源操作系统训练营 - 学习记录
---
## 2022-07-01
学习Rust圣经 3.2.1章：理解并掌握了Rust的闭包、Fn系列特征。

闭包较难理解的一点是**捕获方式**、**Fn系列特征**、**使用方式**三者之间的关系。

理解后梳理如下：

- 闭包实现的**Fn系列特征**，取决于自由变量在闭包内的**使用方式**。
- 自由变量的**捕获方式**，取决于闭包实现的**Fn系列特征**。
- `move`关键字：能改变自由变量的**捕获方式**，但不影响实现的**Fn系列特征**。（原因见第一点）

## 2022-07-02
思考：闭包的生命周期。

Rust圣经之中，对闭包的生命周期一笔带过，遂去其他地方搜索，得出闭包的生命周期主要通过**Fn系列特征**来显式标注。

而对**Fn系列特征**进行生命周期标注时，有时候会有**Early bound**与**Late bound**的区别冲突，为此引入了**HRTB**。

此时深感当初生命周期章节学得不扎实，欠下了许多技术债。

## 2022-07-03
深入学习了昨天未学完的HRTB相关知识，并参考《Rust参考手册》对生命周期相关的知识进行了查漏补缺。

在生命周期省略的章节，发现了许多没学过的用法：在trait对象上进行生命周期省略。

与昨天的闭包生命周期知识点相结合，又扣上了缺失的一环。

## 2022-07-04
学习Rust圣经 3.2.2章：理解迭代器

迭代器对于我来说还算是比较陌生的概念，所以理解的时候免不了磕磕绊绊、绕进误区。

我主要遇到的误区如下：

**1. 跟闭包一样，迭代器有独立的、复杂的“迭代器类型”？**

> 错，迭代器可以是任何类型：只要实现了`Iterator`特征.

**2. Array 与 Vec 都是迭代器类型？**

> 不是，它们调用`.into_iter()`转换成的迭代器是`IntoIter`类型.

**3. `iter()`与`iter_mut()`与`into_iter()`分别来源于不同的trait？**

> 否，都是来源于`IntoIterator trait`，只不过标准库里对于`T`、`&T`、`&mut T`都实现一次这个trait。
> 
> `iter()`与`iter_mut()`实际上是对应`&T`与`&mut T`实现的`into_iter()`方法的别名。

若理解有错，还请指正！

## 2022-07-05
今天去标准库转了一圈，掌握了迭代器大致拥有的方法。

学习了Rust圣经 3.3章 深入类型，浏览了一遍，过程比较顺畅，没有什么误区。

## 2022-07-06
学习Rust圣经 3.3.1章，学到类型别名的时候，突然想起来之前学Trait章节的时候，有一个叫关联类型的东西。

回去又把关联类型深入复习了一遍，突然有个疑问，那关联类型那么多优点，何不完全替代泛型呢？

于是开始研究**关联类型**与**泛型**之间，各自的用法特点。

我首先想起来的就是：泛型能被编译器自动推导，而关联类型不行。（这显然是错误的……因为在实现trait时，泛型还不能自动推导……）

而后我查阅资料，又发现一个区别：**泛型能编译时代码膨胀**，而关联类型不行。也就是说，对不同的参数，泛型会使一个Trait变成多个不同的Trait，但是对不同参数的关联类型，始终只有一个Trait。

所以，使用泛型，可以让Trait对不同的泛型参数都实现一次。但如果想限制实现具有**唯一性**，那就用关联类型。

比如说：`Deref trait`，使类型只能解引用为一个唯一的类型，那就要用关联类型。如果用泛型，就允许对不同类型参数多次实现`Deref trait`，显然是不合理的。

对于泛型的代码膨胀，我有一个新奇的发现：泛型可以看作**类名里面的变量**，对不同输入变量，类名是不同的，因此会产生不同的类型。

## 2022-07-07
深入学习了Sized trait相关的知识。

分享一篇非常好的公众号文章：[《【译】Rust中的Sizeness》](https://mp.weixin.qq.com/s/5eRaXMewRqdyrnwhYU3HIg)，这篇文章详细介绍了关于Sized trait的方方面面，非常详尽周到。

今天的学习解开了一些似懂非懂的地方，比如Trait的对象安全。之前不知道对象安全的Trait不能直接使用Self是什么原因，一直以为是硬性要求，只能死记硬背，看完Sized trait后终于恍然大悟，原来根本原因是因为**Trait对象类型会自动实现对应的Trait**，所以他的Self类型是DST类型，不能直接使用，就是这么简单。

读完有一种直拍大腿，相见恨晚的畅快感！

## 2022-07-08
重读了几遍昨天的那篇文章，深刻参悟了其中的奥妙，并整理成笔记。

## 2022-07-09

## 2022-07-10

## 2022-07-11
学习Rust圣经 3.4.1 Box智能指针

智能指针总感觉很模糊，很不系统。学完之后感觉似懂非懂，没什么大的收获。

不过弄明白了在Rust中，递归类型是要通过智能指针来实现，这样就可以实现链表了！

## 2022-07-12
学习shell基础命令操作。

感觉我自身基础太差了啊，很多必需的技能都没有掌握。

# 2022-07-13
学习Rust圣经 3.4.2 Deref trait

智能指针和引用是不同的概念，并不能说引用就是智能指针。

解引用操作符*只能对引用类型解引用，智能指针之所以可以解引用，就是通过隐式调用Deref trait中的deref()方法，把智能指针转换成引用。

说起来，我个人认为，学习Rust的一个很重要的一点是要弄明白什么时候会隐式转换。弄清楚各种隐式强转以及对应的强转点，很多问题就迎刃而解了。

# 2022-07-14
学习Rust圣经 3.4.3 Drop trait

这一节比较容易混淆的是手动drop()与自动drop()：这两个并不是同一个函数。

- 自动drop()指的是`std::ops::Drop::drop()`，参数获取对象的可变引用，因此析构后依然能访问该对象，非常不安全，因此只能由编译器自动管理调用，不能手动调用。

- 手动的drop()是`std::mem::drop()`，参数获取对象的所有权，并且在函数结束的时候会**自动调用`std::ops::Drop::drop()`**，将参数对象析构。算是曲线救国，达到了析构对象的目的。

# 2022-07-15
学习Rust圣经 3.4.4 Rc与Arc

Rc与Arc的区别只在用途上：Rc用于单线程，性能较高；Arc用于多线程，性能较低。

Rc与Arc的引用计数：只能不可变引用，每次`Clone`新增引用时，计数+1；每次`Drop`释放引用时，计数-1；计数为0时，`Drop`会清理内部数据。

# 2022-07-16
学习Rust圣经 3.4.5 Cell与RefCell

内部可变性：存在不可变引用时，可修改数据，通过unsafe代码块实现。

Cell与RefCell的内部可变性，区别在所有权行为上：Cell的可变依靠所有权转移，RefCell的可变依靠创建可变引用。

# 2022-07-17
继续学习Cell与RefCell

RefCell也使用了引用计数功能，用于在运行时检查借用的合法性。但是由于RefCell可以创建可变借用，所以引用计数的规则与Rc的不同。

首先，Rc本身是对内部数据的一次引用，因此Rc初始引用计数是1；而RefCell本身只是包含数据，并没有引用内部数据。因此RefCell的初始引用计数是0。

然后，与Rc类似，RefCell每次调用`borrow()`进行不可变借用时，引用计数+1；不可变引用释放时，引用计数-1。

但是RefCell还可以通过调用`borrow_mut()`进行可变借用，此时引用计数-1；释放时+1。

RefCell在每次调用`borrow()`或者`borrow_mut()`时，会检查当前的引用计数：

- 若计数小于0，则说明当前存在可变借用，调用`borrow()`或者`borrow_mut()`都会触发panic。
- 若计数大于0，则说明当前存在不可变借用，可以调用`borrow()`，但调用`borrow_mut()`会触发panic。
- 若计数等于0，则说明当前没有借用，`borrow()`或者`borrow_mut()`都能安全调用。

顺带一提，Rc的引用计数不会小于0，所以是`usize`类型；而RefCell的引用计数是`isize`类型。

# 2022-07-18
Rust的学习告一段落，今天开始完成实验要求。

首先是Rustlings，由于不熟悉新的环境，捣鼓了好久才弄好。

刷了35题。

# 2022-07-19
Rustlings一路刷到了76题，暴露了很多缺点：

1. 编码水平停留在纸上谈兵，实际编码磕磕绊绊，困难重重。
2. 标准库API还不太了解，有一些难点无从下手。
3. 多线程与宏编程几乎一窍不通。

明天可以做完Rustlings啦，不过看来也没时间补足以上的短板了，lab实验还没开始做。。。

# 2022-07-20

